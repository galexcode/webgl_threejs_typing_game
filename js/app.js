// Generated by CoffeeScript 1.3.3
(function() {
  var Stage, Text,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    _this = this;

  Stage = (function() {

    function Stage() {
      var cell, light, plane, row, text, x, z, _ref, _ref1;
      this.frame = 0;
      this.map = [['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'], ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'], ['Z', 'X', 'C', 'V', 'B', 'N', 'M']];
      this.scene = new THREE.Scene();
      this.scene.fog = new THREE.Fog(0x000000, 250, 2400);
      this.positions = {};
      this.all = [];
      _ref = this.map;
      for (z in _ref) {
        row = _ref[z];
        _ref1 = this.map[z];
        for (x in _ref1) {
          cell = _ref1[x];
          text = new Text(cell, x, z);
          this.all.push(text);
          this.positions[cell] = text;
          this.scene.add(text.mesh);
        }
      }
      this.camera = new THREE.PerspectiveCamera(40, document.width / document.height, 1, 10000);
      this.camera.position.y = 300;
      this.camera.position.z = 1000;
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(document.width, document.height);
      this.renderer.setClearColor(this.scene.fog.color, 1);
      document.body.appendChild(this.renderer.domElement);
      light = new THREE.DirectionalLight(0xFFFFFF);
      light.position = {
        x: 100,
        y: 1000,
        z: 1000
      };
      this.scene.add(light);
      this.pointLight = new THREE.PointLight(0xffffff, 1.5);
      this.pointLight.position.set(0, 100, 90);
      this.pointLight.color.setHSV(Math.random(), 0.95, 0.85);
      this.scene.add(this.pointLight);
      this.control = new THREE.TrackballControls(this.camera, this.renderer.domElement);
      this.projector = new THREE.Projector();
      plane = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.8,
        transparent: true
      }));
      plane.position.y = 100;
      plane.rotation.x = -Math.PI / 2;
      this.scene.add(plane);
    }

    Stage.prototype.render = function() {
      var index;
      if (Math.random() <= 0.1) {
        index = parseInt(Math.random() * this.all.length);
        if (!this.all[index].jumping) {
          this.all[index].jump();
        }
      }
      this.control.update();
      TWEEN.update();
      return this.renderer.render(this.scene, this.camera);
    };

    return Stage;

  })();

  Text = (function() {
    var faceMaterial, geometoryConf, textHitMaterialFront, textHitMaterialSide, textMaterialFront, textMaterialSide;

    faceMaterial = new THREE.MeshFaceMaterial();

    textMaterialFront = new THREE.MeshBasicMaterial({
      color: 0x00ff00,
      opacity: 1
    });

    textMaterialSide = new THREE.MeshBasicMaterial({
      color: 0x33ff33
    });

    textHitMaterialFront = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      opacity: 1
    });

    textHitMaterialSide = new THREE.MeshBasicMaterial({
      color: 0xff3333
    });

    geometoryConf = {
      size: 70,
      height: 20,
      curveSegments: 4,
      font: "optimer",
      weight: "bold",
      style: "normal",
      material: 0,
      extrudeMaterial: 1
    };

    function Text(char, x, z) {
      this.hit = __bind(this.hit, this);

      var centerOffset, textGeo, textMesh1;
      this.char = char;
      this.jumping = false;
      textGeo = new THREE.TextGeometry(this.char, geometoryConf);
      textGeo.materials = [textMaterialFront, textMaterialSide];
      textGeo.computeBoundingBox();
      textGeo.computeVertexNormals();
      centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
      textMesh1 = new THREE.Mesh(textGeo, faceMaterial);
      textMesh1.position = {
        x: centerOffset + (x * 110) - 500,
        y: 0,
        z: z * 150
      };
      textMesh1.rotation.x = 0;
      textMesh1.rotation.y = Math.PI * 2;
      this.mesh = textMesh1;
    }

    Text.prototype.jump = function() {
      var to,
        _this = this;
      this.jumping = true;
      to = (Math.random() * 100) + 100;
      return this.tween = new TWEEN.Tween(this.mesh.position).to({
        y: to
      }, 1000).onComplete(function() {
        return new TWEEN.Tween(_this.mesh.position).to({
          y: 0
        }, 1000).onComplete(function() {
          return _this.jumping = false;
        }).easing(TWEEN.Easing.Quintic.EaseOut).start();
      }).easing(TWEEN.Easing.Quintic.EaseOut).start();
    };

    Text.prototype.hit = function() {
      var _this = this;
      if (this.jumping) {
        this.jumping = false;
        window.pointAdd(this.char);
        this.mesh.geometry.materials = [textHitMaterialFront, textHitMaterialSide];
        return setTimeout(function() {
          return _this.mesh.geometry.materials = [textMaterialFront, textMaterialSide];
        }, 500);
      }
    };

    return Text;

  })();

  this.stage = new Stage();

  this.addEventListener("DOMContentLoaded", function() {
    this.stage.render();
    return (function(stage) {
      return setInterval(function() {
        return stage.render();
      }, 100);
    })(this.stage);
  });

  this.pointAdd = function(char) {
    var point;
    point = _this.document.getElementById('point').innerHTML;
    return _this.document.getElementById('point').innerHTML = parseInt(point) + 1;
  };

  this.document.onkeydown = function(e) {
    var char, _ref;
    char = String.fromCharCode(e.keyCode);
    char = char.toUpperCase();
    return (_ref = _this.stage.positions[char]) != null ? typeof _ref.hit === "function" ? _ref.hit() : void 0 : void 0;
  };

}).call(this);
